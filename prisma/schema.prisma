generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

enum Role {
  super_admin
  admin
  manager
  employee
}

enum Action {
  create
  read
  update
  delete
}

enum Status {
  active
  inactive
  pending
  suspended
}

enum TaxMode {
  inclusive
  exclusive
}

enum Tier {
  free
  basic
  premium
}

enum SupplierState {
  primary
  secondary
}

enum AdjustmentType {
  DAMAGE
  REFUND
  RETURN
  EXCHANGE
}

enum DamageSubCategory {
  SCRAP
  RESELLABLE
  NON_SELLABLE
}

enum PaymentMethod {
  CASH
  CARD
  BANK_TRANSFER
  CHECK
  DIGITAL_WALLET
}

enum SaleStatus {
  PENDING
  COMPLETED
  CANCELLED
  REFUNDED
  PARTIALLY_RETURNED
}

enum PaymentStatus {
  PAID
  PARTIAL
  UNPAID
  OVERDUE
}

model Clients {
  id           String   @id @default(uuid())
  name         String
  email        String   @unique
  phone        String?
  address      String?
  contactName  String?
  databaseUrl  String?
  databaseName String?
  tier         Tier
  dataSizeMB   String?
  status       Status   @default(active)
  createdAt    DateTime @default(now())
  updatedAt    DateTime @updatedAt

  users        Users[]
  stores       Stores[]
  products     Products[]
  customers    Customer[]
  sales        Sales[]
}

model Users {
  id           String   @id @default(uuid())
  googleId     String?  @unique
  firstName    String
  lastName     String
  email        String   @unique
  passwordHash String?
  googleRefreshToken String?
  otp          String?
  otpExpiresAt DateTime?
  isOtpUsed    Boolean?  @default(false)
  role         String?
  clientId     String
  status       Status   @default(active)
  createdAt    DateTime @default(now())
  updatedAt    DateTime @updatedAt

  employeeCode String?  @unique
  position     String?
  department   String?
  phone        String?

  client         Clients           @relation(fields: [clientId], references: [id])
  stores         UserStoreMap[]
  inviteLinks    InviteLinks[]
  permissions    Permission[]      @relation("UserPermissions")
  grantedPermissions Permission[]  @relation("PermissionGrantedBy")
  createdRoleTemplates RoleTemplate[] @relation("CreatedRoleTemplates")
  userRoles      UserRole[]
  assignedUserRoles UserRole[]     @relation("AssignedUserRoles")
  sales          Sales[]
  purchaseOrders PurchaseOrders[]
  expenses       Expenses[]
  notifications  Notifications[]
  auditLogs      AuditLogs[]
  apiTokens      ApiTokens[]
  passwordResetTokens PasswordResetTokens[]
  saleAdjustments SaleAdjustment[]
  processedReturns SaleReturn[]
}

model Stores {
  id          String   @id @default(uuid())
  name        String
  address     String?
  phone       String?
  email       String?
  logo        String?
  clientId    String
  status      Status   @default(active)
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  client          Clients           @relation(fields: [clientId], references: [id])
  settings        StoreSettings?
  users           UserStoreMap[]
  permissions     Permission[]
  products        Products[]
  suppliers       Suppliers[]
  sales           Sales[]
  purchaseOrders  PurchaseOrders[]
  expenses        Expenses[]
  reports         Reports[]
  FileUploadInventory FileUploadInventory[]
  FileUploadSales     FileUploadSales[]
  saleAdjustments SaleAdjustment[]
  customers       Customer[]
}

model SaleAdjustment {
  id                String           @id @default(uuid())
  saleId            String
  productId         String
  userId            String
  storeId           String
  adjustmentType    AdjustmentType
  damageSubCategory DamageSubCategory? // Only for DAMAGE type
  quantity          Int
  amount            Float            // Amount affected (e.g., refund amount, damage cost)
  addToRevenue      Boolean?         // For REFUND: whether to add to revenue
  addToInventory    Boolean?         // For RETURN: whether to add to inventory
  replacementProductId String?       // For EXCHANGE: ID of replacement product
  reason            String?          // Optional reason for adjustment  createdAt         DateTime         @default(now())
  updatedAt         DateTime         @updatedAt
  sale              Sales            @relation(fields: [saleId], references: [id], onDelete: Cascade)
  product           Products         @relation("ProductAdjustments", fields: [productId], references: [id])
  user              Users            @relation(fields: [userId], references: [id])
  store             Stores           @relation(fields: [storeId], references: [id])
  replacementProduct Products?       @relation("ReplacementProduct", fields: [replacementProductId], references: [id])
}

model Customer {
  id              String   @id @default(uuid())
  customerName    String
  customerAddress String?
  phoneNumber     String   @unique
  telephoneNumber String?
  customerMail    String?
  storeId         String
  clientId        String
  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt

  store           Stores         @relation(fields: [storeId], references: [id])
  client          Clients        @relation(fields: [clientId], references: [id])
  sales           Sales[]
  balanceSheets   BalanceSheet[]
  invoices        Invoice[]
}

model Sales {
  id              String        @id @default(uuid())
  customerId      String
  userId          String
  storeId         String
  clientId        String
  paymentMethod   PaymentMethod
  totalAmount     Float
  tax             Float         @default(0)
  status          SaleStatus    @default(PENDING)
  generateInvoice Boolean       @default(true)
  cashierName     String
  createdAt       DateTime      @default(now())
  updatedAt       DateTime      @updatedAt
  fileUploadSalesId String?
  
  customer        Customer      @relation(fields: [customerId], references: [id])
  user            Users         @relation(fields: [userId], references: [id])
  store           Stores        @relation(fields: [storeId], references: [id])
  client          Clients       @relation(fields: [clientId], references: [id])
  fileUploadSales          FileUploadSales?       @relation(fields: [fileUploadSalesId], references: [id])
  saleItems       SaleItem[]
  saleAdjustments SaleAdjustment[]
  invoices        Invoice[]
  returns         SaleReturn[]
  balanceSheets   BalanceSheet[]
}

model SaleItem {
  id              String   @id @default(uuid())
  saleId          String
  productId       String?
  pluUpc          String
  productName     String
  quantity        Int
  sellingPrice    Float
  totalPrice      Float
  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt

  sale            Sales    @relation(fields: [saleId], references: [id], onDelete: Cascade)
  product         Products? @relation(fields: [productId], references: [id])
}

model Invoice {
  id              String   @id @default(uuid())
  saleId          String
  customerId      String
  invoiceNumber   String   @unique
  customerName    String
  customerPhone   String
  customerMail    String?
  companyName     String?
  companyMail     String?
  companyAddress  String?
  companyNo       String?
  shippingAddress String?
  paymentMethod   PaymentMethod
  totalAmount     Float
  tax             Float
  status          SaleStatus
  cashierName     String
  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt

  sale            Sales    @relation(fields: [saleId], references: [id])
  customer        Customer @relation(fields: [customerId], references: [id])
}

model BalanceSheet {
  id              String        @id @default(uuid())
  customerId      String
  saleId          String?
  remainingAmount Float
  amountPaid      Float
  paymentStatus   PaymentStatus @default(UNPAID)
  description     String?
  createdAt       DateTime      @default(now())
  updatedAt       DateTime      @updatedAt

  customer        Customer      @relation(fields: [customerId], references: [id])
  sale            Sales?        @relation(fields: [saleId], references: [id])
}

model SaleReturn {
  id              String        @id @default(uuid())
  saleId          String
  productId       String?
  pluUpc          String
  quantity        Int
  returnCategory  String
  reason          String?
  processedBy     String
  createdAt       DateTime      @default(now())
  updatedAt       DateTime      @updatedAt

  sale            Sales         @relation(fields: [saleId], references: [id])
  product         Products?      @relation(fields: [productId], references: [id])
  processedByUser Users         @relation(fields: [processedBy], references: [id])
}

// Other models (StoreSettings, UserStoreMap, InviteLinks, etc.) remain unchanged
model StoreSettings {
  id                String   @id @default(uuid())
  storeId          String   @unique
  currency         String   @default("USD")
  timezone         String
  taxRate          Float    @default(0)
  taxMode          TaxMode  @default(exclusive)
  lowStockAlert    Int      @default(10)
  enableNotifications Boolean @default(true)
  createdAt        DateTime @default(now())
  updatedAt        DateTime @updatedAt

  store            Stores   @relation(fields: [storeId], references: [id])
}

model UserStoreMap {
  id        String   @id @default(uuid())
  userId    String
  storeId   String
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  user      Users    @relation(fields: [userId], references: [id])
  store     Stores   @relation(fields: [storeId], references: [id])

  @@unique([userId, storeId])
}

model InviteLinks {
  id        String   @id @default(uuid())
  email     String
  token     String   @unique
  role      Role
  userId    String
  status    Status   @default(pending)
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  user      Users    @relation(fields: [userId], references: [id])
}

model Permission {
  id            String   @id @default(cuid())
  userId        String
  storeId       String?
  resource      String
  actions       String[]
  resourceId    String?
  granted       Boolean  @default(true)
  grantedBy     String
  grantedAt     DateTime @default(now())
  expiresAt     DateTime?
  conditions    Json?
  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt

  user          Users    @relation("UserPermissions", fields: [userId], references: [id], onDelete: Cascade)
  store         Stores?  @relation(fields: [storeId], references: [id], onDelete: Cascade)
  grantedByUser Users    @relation("PermissionGrantedBy", fields: [grantedBy], references: [id])

  @@unique([userId, storeId, resource, resourceId])
  @@index([userId, storeId])
  @@index([resource])
  @@map("permissions")
}

model RoleTemplate {
  id          String   @id @default(cuid())
  name        String   @unique
  description String?
  permissions Json
  inheritsFrom String?
  isDefault   Boolean  @default(false)
  isActive    Boolean  @default(true)
  priority    Int      @default(0)
  createdBy   String
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  creator     Users        @relation("CreatedRoleTemplates", fields: [createdBy], references: [id])
  parent      RoleTemplate? @relation("RoleInheritance", fields: [inheritsFrom], references: [id])
  children    RoleTemplate[] @relation("RoleInheritance")
  userRoles   UserRole[]

  @@map("role_templates")
}

model UserRole {
  id             String       @id @default(cuid())
  userId         String
  roleTemplateId String
  storeId        String?
  assignedBy     String
  assignedAt     DateTime     @default(now())
  isActive       Boolean      @default(true)
  createdAt      DateTime     @default(now())

  user         Users        @relation(fields: [userId], references: [id], onDelete: Cascade)
  roleTemplate RoleTemplate @relation(fields: [roleTemplateId], references: [id], onDelete: Cascade)
  assignedByUser Users      @relation("AssignedUserRoles", fields: [assignedBy], references: [id])

  @@unique([userId, roleTemplateId, storeId])
  @@map("user_roles")
}

model Notifications {
  id        String   @id @default(uuid())
  userId    String
  title     String
  message   String
  read      Boolean  @default(false)
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  user      Users    @relation(fields: [userId], references: [id])
}

model AuditLogs {
  id        String   @id @default(uuid())
  userId    String
  action    String
  resource  String
  details   Json?
  createdAt DateTime @default(now())

  user      Users    @relation(fields: [userId], references: [id])
}

model ApiTokens {
  id        String   @id @default(uuid())
  userId    String
  token     String   @unique
  name      String
  expiresAt DateTime?
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  user      Users    @relation(fields: [userId], references: [id])
}

model PasswordResetTokens {
  id        String   @id @default(uuid())
  userId    String
  token     String   @unique
  expiresAt DateTime
  usedAt    DateTime?
  createdAt DateTime @default(now())

  user      Users    @relation(fields: [userId], references: [id], onDelete: Cascade)
}

model Suppliers {
  id          String          @id @default(uuid())
  name        String
  email       String?
  phone       String
  address     String?
  storeId     String
  status      Status          @default(active)
  createdAt   DateTime        @default(now())
  updatedAt   DateTime        @updatedAt

  store       Stores          @relation(fields: [storeId], references: [id])
  productSuppliers ProductSupplier[]
  purchaseOrders  PurchaseOrders[]
}

model PurchaseOrders {
  id          String   @id @default(uuid())
  productId   String
  supplierId  String
  userId      String
  storeId     String
  quantity    Int
  price       Float
  total       Float
  status      Status   @default(pending)
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  product     Products  @relation(fields: [productId], references: [id])
  supplier    Suppliers @relation(fields: [supplierId], references: [id])
  user        Users     @relation(fields: [userId], references: [id])
  store       Stores    @relation(fields: [storeId], references: [id])
}

model Expenses {
  id          String   @id @default(uuid())
  userId      String
  storeId     String
  amount      Float
  description String
  date        DateTime
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  user        Users     @relation(fields: [userId], references: [id])
  store       Stores    @relation(fields: [storeId], references: [id])
}

model Reports {
  id          String   @id @default(uuid())
  storeId     String
  type        String
  data        Json
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  store       Stores    @relation(fields: [storeId], references: [id])
}

model ProductSupplier {
  id          String        @id @default(uuid())
  productId   String
  supplierId  String
  costPrice   Float
  category    String
  state       SupplierState @default(secondary)
  createdAt   DateTime      @default(now())
  updatedAt   DateTime      @updatedAt

  product     Products?      @relation(fields: [productId], references: [id], onDelete: Cascade)
  supplier    Suppliers?     @relation(fields: [supplierId], references: [id], onDelete: Cascade)

  @@unique([productId, supplierId])
}

model Products {
  id                    String    @id @default(uuid())
  name                  String
  category              String
  ean                   String?
  pluUpc                String?  
  sku                   String?
  itemQuantity          Int
  msrpPrice             Float
  singleItemSellingPrice Float
  clientId              String
  storeId               String
  discountAmount        Float
  percentDiscount       Float
  hasVariants           Boolean   @default(false)
  packIds               String[]  @default([])
  packs                 Pack[]
  variants              Json[]    
  createdAt             DateTime  @default(now())
  updatedAt             DateTime  @updatedAt
  fileUploadId          String?     
  client                Clients   @relation(fields: [clientId], references: [id])
  store                 Stores    @relation(fields: [storeId], references: [id])
  productSuppliers      ProductSupplier[]
  saleItems             SaleItem[]
  fileUpload            FileUploadInventory? @relation(fields: [fileUploadId], references: [id])
  purchaseOrders        PurchaseOrders[]
  saleAdjustments       SaleAdjustment[]  @relation("ProductAdjustments")
  replacementAdjustments SaleAdjustment[] @relation("ReplacementProduct")
  returns               SaleReturn[]
}

model Pack {
  id                    String    @id @default(uuid())
  productId             String
  minimumSellingQuantity Int
  totalPacksQuantity    Int
  orderedPacksPrice     Float
  discountAmount        Float
  percentDiscount       Float
  createdAt             DateTime  @default(now())
  updatedAt             DateTime  @updatedAt
  product               Products  @relation(fields: [productId], references: [id])
}

model FileUploadInventory {
  id         String      @id @default(cuid())
  fileHash   String      @unique
  fileName   String
  uploadedAt DateTime    @default(now())
  storeId    String?
  status     String      @default("pending")
  error      String?
  products   Products[]
  store      Stores?     @relation(fields: [storeId], references: [id])
  errorLogs  ErrorLog[]
}

model ErrorLog {
  id           String    @id @default(cuid())
  fileUploadId String
  rowNumber    Int
  error        String
  createdAt    DateTime  @default(now())
  fileUpload   FileUploadInventory @relation(fields: [fileUploadId], references: [id])
}

model FileUploadSales {
  id         String   @id @default(cuid())
  fileHash   String   @unique
  fileName   String
  uploadedAt DateTime @default(now())
  storeId    String?
  Store      Stores?   @relation(fields: [storeId], references: [id])
  Sale       Sales[]
}